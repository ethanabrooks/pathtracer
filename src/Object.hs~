{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE ExistentialQuantification #-}

module Object where

import qualified Data.Array.Repa     as R -- for Repa
import Data.Array.Repa (Array, DIM1, DIM2, U, D, Z (..), (:.)(..), (!), (++), (*^))
import Data.Array.Repa.Repr.Unboxed (Unbox)
import Data.Vector.Unboxed (Vector, MVector)
import qualified Data.Vector.Primitive as P
import Data.Array.Repa.Eval (Elt)
-- import Data.Vector.Unboxed (Vector)
import Lib (Vec3, Vec1, Rays (..), _num, _origins, _distances, inf, lessThan,
            filterWith, filterBy1, filterBy3)
import Debug.Trace
import Data.Maybe

data Form = Disk
            { _center :: Vec1
            , _normal :: Vec1 }
          | InfinitePlane
            { _normal :: Vec1 }
 
data Object = Object { _color :: Vec1
                     , _light :: Array D DIM1 Bool
                     , _form  :: Form }


infPlane = Object 
  { _color = R.fromFunction (Z :. 3) $ const 1
  , _light = R.fromFunction (Z :. 3) $ const False
  , _form  = InfinitePlane
             { _normal = R.fromFunction (Z :. 3) $ const 1 } }

distanceFrom :: Rays -> Object -> Vec1
distanceFrom rays object = R.fromFunction (Z :. 0) $ const 0 -- TODO


intersectWith :: Rays -> Vec3 -> Vec3
rays `intersectWith` points = points -- TODO

-- filterRaysBy array rays cond = Rays
--   { _origins   = origins'
--   , _distances = distances'
--   , _num       = num' }
--   where origins'    = filterBy array cond $ _origin rays
--         distances'  = filterBy array cond $ _distances rays
--         (Z :. num') = R.extent distances'

bounce :: (Rays, Array D DIM1 (Array D DIM1 Float)) -> (Rays, Array D DIM1 (Array D DIM1 Float))
bounce (rays, canvas) = fromJust $ do
        -- get distances to closest objects
        let distancesToObjects = map (distanceFrom rays) objects :: [Vec1]
        let closestObjectIdxs  = minIndex distancesToObjects     :: Array D DIM1 (Maybe Int)
        let getDistance _ i    = case closestObjectIdxs ! i of
                                   Nothing -> inf
                                   Just j  -> distancesToObjects !! j ! i :: Float -- TODO
        let closestDistances   = R.traverse closestObjectIdxs id getDistance

        -- get values for new rays
        let Rays { _origins   = origins
                 , _vectors   = vectors
                 , _distances = distances
                 , _pixels    = pixels 
                 , _num       = num } = rays

        let isJust Nothing  = False
        let isJust (Just _) = True

        distances'      <- closestDistances `filterWith` (closestObjectIdxs, isJust) :: Maybe Vec1
        let points      = origins --TODO
        let origins'    = rays `intersectWith` points                          :: Vec3 
        let (Z :. num') = R.extent distances'
        let rays' = Rays { _origins   = origins'
                         , _distances = distances'
                         , _pixels    = pixels -- TODO
                         , _vectors   = vectors -- TODO
                         , _num       = num' }

        -- for new canvas
        let canvas' = R.traverse closestObjectIdxs id (\f i -> let objectColor = getColor $ f i
                                                               in (canvas ! i) *^ objectColor)
        return (rays', canvas')
  
mapRows ::
  (Elt a, Unbox a, Elt b, Unbox b) =>
  Int -> (a -> (Array D DIM1 b)) -> Array D DIM1 a -> Array D DIM2 b
mapRows w f array = R.fromFunction (Z :. h :. w) (\(Z :. i :. j) -> rows ! (Z :. i) ! (Z :. j))
         where (Z :. h) = R.extent array 
               rows = R.map f array

dvec = R.fromFunction (Z :. 2) (\(Z :. i) -> R.fromFunction (Z :. 3) (\(Z :. j) -> i + j))
dobj = R.fromFunction (Z :. 2) $ const infPlane
                        
intersectionWith :: Rays -> Object -> Vec1
rays `intersectionWith` object = R.fromFunction (Z :. 3) $ const 0 --TODO

origins' :: Array D DIM1 (Array D DIM1 Int)
origins' = R.fromFunction (Z :. 10) $ \(Z :. x) -> R.fromFunction (Z :. 3) $ \(Z :. y) -> y
          

getColor :: Int -> Array D DIM1 Float
getColor i = _color $ objects !! i


-- TODO lights?

objects = [infPlane]

-- distancesFrom :: Rays -> Array D DIM2 Float
-- distancesFrom rays = foldl (R.append) empty $ map (distanceFrom rays) objects
--   where empty = R.fromFunction (Z :. numRays :. 0) $ const 0

-- distances' :: Rays -> Maybe (Array U DIM1 Float)
-- distances' rays = R.foldP min inf (distancesFrom rays)

constant :: R.Shape sh => sh -> Float -> Array D sh Float
constant sh val = R.fromFunction sh $ const val

zeros :: R.Shape sh => sh -> Array D sh Float
zeros sh = constant sh 0

zeros' = zeros (Z :. 10) :: Vec1

minIndexOf2 :: (Vec1, Array D DIM1 (Maybe Int)) -> (Vec1, Int) -> (Vec1, Array D DIM1 (Maybe Int))
minIndexOf2 (minVal, minIdx) (val, idx) = (R.zipWith min minVal val, minIdx')
  where minIdx' = R.fromFunction (R.extent minVal) (\sh -> if (val `lessThan` minVal ! sh)
                                                           then Just idx
                                                           else minIdx ! sh)

minIndex :: [Vec1] -> Array D DIM1 (Maybe Int)
minIndex arrays = minIdx
  where (_, minIdx) = foldl minIndexOf2 (infs, nothings) $ zip arrays [0..]
        infs        = R.fromFunction shape $ const inf
        nothings    = R.fromFunction shape $ const Nothing
        shape       = (Z :. round inf)
        


-- closestObjectIdxs rays = minIndex $ map (distanceFrom rays) objects
  -- case arrays of
  --                   []        -> fail "Doesn't work on empty list"
  --                   head:tail -> let zeros = R.fromFunction (R.extent a) $ const 0
  --                                    (_, minIdx) = foldl minIndexOf2 (head, zeros) $ zip tail [1..]
  --                                in  return minIdx

-- f :: Monad m => m (Int)
-- f = do
--   x:xs <- []
--   return x
  
-- closestObjectPtrs rays = R.foldP maxIdx -1 (distancesFrom rays)
--   where maxIdx idx1 idx2 = case (idx1, idx2) of
-- minIndex :: (R.Shape sh, Ord e) => [Array D sh e] -> Maybe (Array D sh e)
-- minIndex arrays =
--   case arrays of
--     []   -> Nothing
--     a:as -> let zero = R.fromFunction (R.extent a) $ const 0
--                 (_, minj) = foldl (\(minSoFar, minj) ((a', j) :: Array D DIM1 Bool, Int) ->
--                                         (R.zipWith min minSoFar a,
--                                          R.fromFunction (R.extent a)
--                                          (\(Z :. i) ->
--                                             if (a' < minSoFar) ! i
--                                             then j
--                                             else minj))) ((a, zero) :: (Array D DIM1 Bool, Array D DIM1 Float)) $ zip as [1..]
--             in Just minj



--   $ \(Z :. x :. y) -> distanceFrom (objects !! y) 
--   where 
-- closest objects = R.foldP max

-- closest objects = R.foldP max $ R.map 
          
            
