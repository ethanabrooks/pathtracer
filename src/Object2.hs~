{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE RankNTypes #-}

module Object2 where

import qualified Data.Array.Repa     as R -- for Repa
import qualified Data.Array.Repa.Shape as S
import qualified Data.Array.Repa.Algorithms.Matrix as M
import qualified Data.Array.Repa.Repr.Unboxed as U
import qualified Codec.Picture as P

import Data.Array.Repa (Array, DIM1, DIM2, DIM3, U, D, Z (..), (:.)(..),
                        (!), (++), (*^), (+^), (-^), (/^))
import Data.Array.Repa.Slice (Any (..), All (..))
-- import Lib (Vec3, Vec1, Rays (..), _num, _origins, _distances, inf,
--             lessThan, filterWith, emptyRays, reshape, expandDim)
import Lib (reshape, expandDim, lessThan, flatten)
import qualified Data.Vector as V
import Data.Maybe
import Control.Monad
import Prelude hiding ((++))

type RGB8 = (P.Pixel8, P.Pixel8, P.Pixel8)
type Vec3 = (Double, Double, Double)
  
data Form = Disk
            { _center :: Vec3
            , _normal :: Vec3
            , _radius :: Double }
          | InfinitePlane
            { _normal :: Vec3
            , _point  :: Vec3 }
 
data Object = Object { _color      :: RGB8
                     , _light      :: Bool
                     , _reflective :: Bool
                     , _form       :: Form }

data Ray = Ray { _origin   :: Vec3
               , _vector   :: Vec3
               , _pixelIdx :: (Int, Int) }

-- | Paramters
imgHeight = 2 :: Int --1200
imgWidth  = 4 :: Int --1200
cameraDepth = 10 :: Double

black = (1, 1, 1)
some_vec = (1, 1, 1)

infPlane = Object 
  { _color      = black
  , _light      = False
  , _reflective = True
  , _form       = InfinitePlane
             { _normal = some_vec
             , _point  = some_vec }
  }


objects :: V.Vector Object
objects = V.fromList [infPlane] 

canvas :: Array U DIM2 RGB8
canvas = R.computeS $ R.fromFunction (Z :. imgHeight :. imgWidth) $ const black



mapWithIndex ::
  (S.Shape sh', R.Source r a) =>
  (sh' -> a -> b) -> Array r sh' a -> Array D sh' b
mapWithIndex f array = R.traverse array id $ ap f

mapIndex ::
  (S.Shape sh', R.Source r a) =>
  (sh' -> b) -> Array r sh' a -> Array D sh' b
mapIndex f array = R.traverse array id $ const f

norm2 :: Floating a => (a, a, a) -> a
norm2 (x, y, z) = sqrt $ x^2 + y^2 + z^2

normalize vector@(x, y, z) = (x / norm, y / norm, z / norm)
  where norm = norm2 vector

raysFromCam :: Array D DIM1 Ray
raysFromCam = flatten $ mapIndex camToPixelRay canvas

camToPixelRay :: DIM2 -> Ray
camToPixelRay (Z :. i :. j)  = Ray { _origin   = (0, 0, 0)
                                   , _vector   = normalize (i', j', cameraDepth)
                                   , _pixelIdx = (i, j) }
  where (i', j') = (fromIntegral i, fromIntegral j)

